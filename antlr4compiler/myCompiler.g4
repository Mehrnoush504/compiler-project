grammar myCompiler;

program: moduleDeclarations otherModules driverModule otherModules;
moduleDeclarations: moduleDeclaration moduleDeclarations | /* epsilon */;
moduleDeclaration: DECLARE MODULE ID SEMICOL;
otherModules: module otherModules | /* epsilon */;
driverModule: DRIVER DEF DRIVER PROGRAM DRIVER ENDDEF moduleDef;
module: DEF MODULE ID ENDDEF TAKES INPUT SQBO input_plist SQBC SEMICOL ret moduleDef;
ret: RETURNS SQBO output_plist SQBC SEMICOL | /* epsilon */;
input_plist:  ID COLON dataType input_plistRec;
input_plistRec: COMMA ID COLON dataType input_plistRec | /* epsilon */;
output_plist: ID COLON type output_plistRec;
output_plistRec: COMMA ID COLON type output_plistRec | /* epsilon */;
type: INTEGER | REAL | BOOLEAN;
dataType: type | ARRAY SQBO range SQBC OF type;
moduleDef: START statements END;
statements: statement statements | /* epsilon */;
statement: ioStmt | simpleStmt | declareStmt |condionalStmt | iterativeStmt | SEMICOL;
ioStmt: GET_VALUE BO ID whichId BC SEMICOL | PRINT BO <var> BC SEMICOL;
whichId: SQBO index SQBC | /* epsilon */;
index: NUM | ID;
simpleStmt: assignmentStmt | moduleReuseStmt;
assignmentStmt: ID whichId ASSIGNOP expression SEMICOL;
moduleReuseStmt: optional USE MODULE ID WITH PARAMETERS idList SEMICOL;
optional: SQBO idList SQBC ASSIGNOP | /* epsilon */;
idList: ID idListRec;
idListRec: COMMA ID idListRec | /* epsilon */;
expression: arithOrBoolExpr | MINUS BO <arithmeticExpr> BC;
arithOrBoolExpr: anyTerm arithOrBoolExprRec;
arithOrBoolExprRec: logicalOp anyTerm arithOrBoolExprRec | /* epsilon */;
anyTerm: arithmeticExpr anyTermRec;
anyTermRec: relationalOp arithmeticExpr anyTermRec | /* epsilon */;
arithmeticExpr: term arithmeticExprRec;
arithmeticExprRec: pm term arithmeticExprRec | /* epsilon */;
term: factor termRec;
termRec: md factor termRec | /* epsilon */;
factor: BO arithOrBoolExpr BC | var;
var: ID whichId | NUM | RNUM | TRUE | FALSE;
pm: PLUS | MINUS;
md: MUL | DIV;
logicalOp: AND | OR;
relationalOp: LT | LE | GT | GE | EQ | NE;
declareStmt: DECLARE idList COLON dataType SEMICOL;
condionalStmt: SWITCH BO ID BC START caseStmts default END;
caseStmts: CASE value COLON statements BREAK SEMICOL caseStmtsRec;
caseStmtsRec: CASE value COLON statements BREAK SEMICOL caseStmtsRec | /* epsilon */;
value: NUM | TRUE | FALSE;
default: DEFAULT COLON statements BREAK SEMICOL | /* epsilon */;
iterativeStmt: FOR BO ID IN range BC START statements END | WHILE BO arithOrBoolExpr BC START statements END;
range: NUM RANGEOP NUM;

//Keywords
INTEGER: 'integer';
REAL: 'real';
BOOLEAN: 'boolean';
OF: 'of';
ARRAY: 'array';
START : 'start';
END: 'end';
DECLARE : 'declare';
MODULE: 'module';
DRIVER: 'driver';
PROGRAM: 'program';
GET_VALUE: 'get_value';
PRINT: 'print';
USE: 'use';
WITH: 'with';
PARAMETERS : 'parameters';
TRUE: 'true';
FALSE: 'false';
//
TAKES: 'takes';
INPUT: 'input';
RETURNS: 'returns';
AND : 'AND';
OR: 'OR';
FOR: 'for';
IN: 'in';
SWITCH: 'switch';
CASE: 'case';
BREAK: 'break';
DEFAULT: 'default';
WHILE: 'while';
//symbols
PLUS: '+';
MINUS: '-';
MUL: '*';
DIV: '/';
LT: '<';
LE: '<=';
GE: '>=';
GT: '>';
EQ: '==';
NE: '!=';
DEF: '<<';
ENDDEF: '>>';
COLON: ':';
RANGEOP: '..';
SEMICOL: ';';
COMMA: ',';
ASSIGNOP: ':=';
SQBO: '[';
SQBC: ']';
BO: '(';
BC: ')';
COMMENTMA: '**';

// Identifiers
ID : ('_'|LETTER)+ ('_'|LETTER|DIGIT)*;
NUM : DIGIT+;
RNUM : ( (NUM? '.' NUM) | (NUM '.') ) EXP?;
WS : [\t\n ]+ -> skip;
fragment LETTER: [a-zA-Z];
fragment DIGIT : [0-9];
fragment EXP: '^'[-+]?NUM;
